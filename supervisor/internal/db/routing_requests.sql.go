// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: routing_requests.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRoutingRequest = `-- name: CreateRoutingRequest :one
INSERT INTO routing_requests (
    request_id, coordinates_x, coordinates_y, selected_node_id, 
    distance, load_score, status, request_data, metadata, client_info
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, request_id, coordinates_x, coordinates_y, selected_node_id, distance, load_score, status, response_time_ms, request_data, response_data, metadata, client_info, processing_metrics, created_at
`

type CreateRoutingRequestParams struct {
	RequestID      string        `json:"request_id"`
	CoordinatesX   float64       `json:"coordinates_x"`
	CoordinatesY   float64       `json:"coordinates_y"`
	SelectedNodeID pgtype.UUID   `json:"selected_node_id"`
	Distance       pgtype.Float8 `json:"distance"`
	LoadScore      pgtype.Float8 `json:"load_score"`
	Status         pgtype.Text   `json:"status"`
	RequestData    []byte        `json:"request_data"`
	Metadata       []byte        `json:"metadata"`
	ClientInfo     []byte        `json:"client_info"`
}

func (q *Queries) CreateRoutingRequest(ctx context.Context, arg CreateRoutingRequestParams) (RoutingRequest, error) {
	row := q.db.QueryRow(ctx, createRoutingRequest,
		arg.RequestID,
		arg.CoordinatesX,
		arg.CoordinatesY,
		arg.SelectedNodeID,
		arg.Distance,
		arg.LoadScore,
		arg.Status,
		arg.RequestData,
		arg.Metadata,
		arg.ClientInfo,
	)
	var i RoutingRequest
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.CoordinatesX,
		&i.CoordinatesY,
		&i.SelectedNodeID,
		&i.Distance,
		&i.LoadScore,
		&i.Status,
		&i.ResponseTimeMs,
		&i.RequestData,
		&i.ResponseData,
		&i.Metadata,
		&i.ClientInfo,
		&i.ProcessingMetrics,
		&i.CreatedAt,
	)
	return i, err
}

const getRecentRoutingRequests = `-- name: GetRecentRoutingRequests :many
SELECT id, request_id, coordinates_x, coordinates_y, selected_node_id, distance, load_score, status, response_time_ms, request_data, response_data, metadata, client_info, processing_metrics, created_at FROM routing_requests 
ORDER BY created_at DESC 
LIMIT $1
`

func (q *Queries) GetRecentRoutingRequests(ctx context.Context, limit int32) ([]RoutingRequest, error) {
	rows, err := q.db.Query(ctx, getRecentRoutingRequests, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoutingRequest
	for rows.Next() {
		var i RoutingRequest
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.CoordinatesX,
			&i.CoordinatesY,
			&i.SelectedNodeID,
			&i.Distance,
			&i.LoadScore,
			&i.Status,
			&i.ResponseTimeMs,
			&i.RequestData,
			&i.ResponseData,
			&i.Metadata,
			&i.ClientInfo,
			&i.ProcessingMetrics,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutingRequestByID = `-- name: GetRoutingRequestByID :one
SELECT id, request_id, coordinates_x, coordinates_y, selected_node_id, distance, load_score, status, response_time_ms, request_data, response_data, metadata, client_info, processing_metrics, created_at FROM routing_requests WHERE id = $1
`

func (q *Queries) GetRoutingRequestByID(ctx context.Context, id pgtype.UUID) (RoutingRequest, error) {
	row := q.db.QueryRow(ctx, getRoutingRequestByID, id)
	var i RoutingRequest
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.CoordinatesX,
		&i.CoordinatesY,
		&i.SelectedNodeID,
		&i.Distance,
		&i.LoadScore,
		&i.Status,
		&i.ResponseTimeMs,
		&i.RequestData,
		&i.ResponseData,
		&i.Metadata,
		&i.ClientInfo,
		&i.ProcessingMetrics,
		&i.CreatedAt,
	)
	return i, err
}

const getRoutingRequestsByNode = `-- name: GetRoutingRequestsByNode :many
SELECT id, request_id, coordinates_x, coordinates_y, selected_node_id, distance, load_score, status, response_time_ms, request_data, response_data, metadata, client_info, processing_metrics, created_at FROM routing_requests 
WHERE selected_node_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRoutingRequestsByNodeParams struct {
	SelectedNodeID pgtype.UUID `json:"selected_node_id"`
	Limit          int32       `json:"limit"`
}

func (q *Queries) GetRoutingRequestsByNode(ctx context.Context, arg GetRoutingRequestsByNodeParams) ([]RoutingRequest, error) {
	rows, err := q.db.Query(ctx, getRoutingRequestsByNode, arg.SelectedNodeID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoutingRequest
	for rows.Next() {
		var i RoutingRequest
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.CoordinatesX,
			&i.CoordinatesY,
			&i.SelectedNodeID,
			&i.Distance,
			&i.LoadScore,
			&i.Status,
			&i.ResponseTimeMs,
			&i.RequestData,
			&i.ResponseData,
			&i.Metadata,
			&i.ClientInfo,
			&i.ProcessingMetrics,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutingRequestsByStatus = `-- name: GetRoutingRequestsByStatus :many
SELECT id, request_id, coordinates_x, coordinates_y, selected_node_id, distance, load_score, status, response_time_ms, request_data, response_data, metadata, client_info, processing_metrics, created_at FROM routing_requests 
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRoutingRequestsByStatusParams struct {
	Status pgtype.Text `json:"status"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetRoutingRequestsByStatus(ctx context.Context, arg GetRoutingRequestsByStatusParams) ([]RoutingRequest, error) {
	rows, err := q.db.Query(ctx, getRoutingRequestsByStatus, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoutingRequest
	for rows.Next() {
		var i RoutingRequest
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.CoordinatesX,
			&i.CoordinatesY,
			&i.SelectedNodeID,
			&i.Distance,
			&i.LoadScore,
			&i.Status,
			&i.ResponseTimeMs,
			&i.RequestData,
			&i.ResponseData,
			&i.Metadata,
			&i.ClientInfo,
			&i.ProcessingMetrics,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRoutingRequests = `-- name: SearchRoutingRequests :many
SELECT id, request_id, coordinates_x, coordinates_y, selected_node_id, distance, load_score, status, response_time_ms, request_data, response_data, metadata, client_info, processing_metrics, created_at FROM routing_requests 
WHERE request_data @> $1::jsonb OR metadata @> $2::jsonb
ORDER BY created_at DESC
LIMIT $3
`

type SearchRoutingRequestsParams struct {
	Column1 []byte `json:"column_1"`
	Column2 []byte `json:"column_2"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) SearchRoutingRequests(ctx context.Context, arg SearchRoutingRequestsParams) ([]RoutingRequest, error) {
	rows, err := q.db.Query(ctx, searchRoutingRequests, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoutingRequest
	for rows.Next() {
		var i RoutingRequest
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.CoordinatesX,
			&i.CoordinatesY,
			&i.SelectedNodeID,
			&i.Distance,
			&i.LoadScore,
			&i.Status,
			&i.ResponseTimeMs,
			&i.RequestData,
			&i.ResponseData,
			&i.Metadata,
			&i.ClientInfo,
			&i.ProcessingMetrics,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoutingResponse = `-- name: UpdateRoutingResponse :one
UPDATE routing_requests 
SET response_data = $2, processing_metrics = $3, response_time_ms = $4, status = $5
WHERE id = $1
RETURNING id, request_id, coordinates_x, coordinates_y, selected_node_id, distance, load_score, status, response_time_ms, request_data, response_data, metadata, client_info, processing_metrics, created_at
`

type UpdateRoutingResponseParams struct {
	ID                pgtype.UUID `json:"id"`
	ResponseData      []byte      `json:"response_data"`
	ProcessingMetrics []byte      `json:"processing_metrics"`
	ResponseTimeMs    pgtype.Int4 `json:"response_time_ms"`
	Status            pgtype.Text `json:"status"`
}

func (q *Queries) UpdateRoutingResponse(ctx context.Context, arg UpdateRoutingResponseParams) (RoutingRequest, error) {
	row := q.db.QueryRow(ctx, updateRoutingResponse,
		arg.ID,
		arg.ResponseData,
		arg.ProcessingMetrics,
		arg.ResponseTimeMs,
		arg.Status,
	)
	var i RoutingRequest
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.CoordinatesX,
		&i.CoordinatesY,
		&i.SelectedNodeID,
		&i.Distance,
		&i.LoadScore,
		&i.Status,
		&i.ResponseTimeMs,
		&i.RequestData,
		&i.ResponseData,
		&i.Metadata,
		&i.ClientInfo,
		&i.ProcessingMetrics,
		&i.CreatedAt,
	)
	return i, err
}
